<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tool T·∫°o B√†i Vi·∫øt SEO v·ªõi ·∫¢nh v√† AI (C√≥ HTML copy)</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
      min-height: 100vh; padding:20px; color:#333;
    }
    .container {
      max-width: 900px; margin:0 auto; background:#fff;
      border-radius:15px; padding:30px; box-shadow:0 20px 40px rgba(0,0,0,0.1);
    }
    h1 {
      text-align:center; margin-bottom: 25px; color:#764ba2;
    }
    .dropzone {
      border: 3px dashed #007bff; border-radius:15px;
      padding: 40px; text-align:center;
      cursor:pointer; margin-bottom: 20px;
      transition: background-color 0.3s ease;
      position: relative;
    }
    .dropzone.dragging {
      background: #f0fff0; border-color: #28a745;
    }
    input[type=file] {
      position:absolute; top:0; left:0; width:100%; height:100%;
      opacity:0; cursor:pointer;
    }
    #qualityLabel {
      margin-bottom: 8px; font-weight: 600;
    }
    #qualityRange {
      width: 100%;
    }
    button {
      background: linear-gradient(45deg,#007bff,#0056b3);
      border:none; color:#fff; padding: 12px 20px;
      font-weight:600; border-radius:8px; cursor:pointer;
      transition: all 0.3s ease; margin-top: 10px;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,123,255,0.3);
    }
    .status {
      margin-top: 15px; padding: 10px;
      border-radius: 5px; text-align:center;
    }
    .bg-success { background:#d4edda; color:#155724; border:1px solid #c3e6cb; }
    .bg-danger { background:#f8d7da; color:#721c24; border:1px solid #f5c6cb; }
    .bg-info { background:#d1ecf1; color:#0c5460; border:1px solid #bee5eb; }

    #resultArea, #htmlArea {
      margin-top: 30px;
      background: #f8f9fa;
      border-radius: 10px;
      padding: 20px;
      white-space: pre-wrap;
      font-family: 'Courier New', Courier, monospace;
      max-height: 400px;
      overflow-y: auto;
      border: 1px solid #ddd;
    }
    #resultArea { display:none; }
    #htmlArea { display:none; margin-top:10px; }

    #btnGroup {
      margin-top: 15px;
    }
    #copyTextBtn, #copyHtmlBtn {
      background: linear-gradient(45deg,#28a745,#20c997);
      border:none; color:#fff; padding:10px 18px; border-radius: 8px;
      cursor:pointer; font-weight:600; margin-right: 10px;
      transition: all 0.3s ease;
    }
    #copyTextBtn:hover, #copyHtmlBtn:hover {
      box-shadow: 0 5px 15px rgba(40,167,69,0.5);
      transform: translateY(-2px);
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üöÄ Tool T·∫°o B√†i Vi·∫øt SEO v·ªõi ·∫¢nh v√† AI (C√≥ HTML copy)</h1>

    <div class="dropzone" id="dropzone">
      <p>üì∏ K√©o th·∫£ ·∫£nh v√†o ƒë√¢y ho·∫∑c click ƒë·ªÉ ch·ªçn ·∫£nh</p>
      <input type="file" id="fileInput" accept="image/*" multiple />
    </div>

    <label id="qualityLabel" for="qualityRange">Ch·∫•t l∆∞·ª£ng n√©n WebP (0.1 - 1): <span id="qualityValue">0.6</span></label>
    <input type="range" id="qualityRange" min="0.1" max="1" step="0.1" value="0.6" />

    <button id="generateBtn">‚úçÔ∏è T·∫°o b√†i vi·∫øt AI</button>

    <div class="status" id="status"></div>

    <pre id="resultArea"></pre>
    <pre id="htmlArea"></pre>

    <div id="btnGroup" style="display:none;">
      <button id="copyTextBtn" title="Copy n·ªôi dung thu·∫ßn">üìã Copy Text thu·∫ßn</button>
      <button id="copyHtmlBtn" title="Copy m√£ HTML ƒëƒÉng Blogger">üìù Copy M√£ HTML</button>
    </div>
  </div>

  <script>
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const qualityRange = document.getElementById('qualityRange');
    const qualityValue = document.getElementById('qualityValue');
    const generateBtn = document.getElementById('generateBtn');
    const statusEl = document.getElementById('status');
    const resultArea = document.getElementById('resultArea');
    const htmlArea = document.getElementById('htmlArea');
    const btnGroup = document.getElementById('btnGroup');
    const copyTextBtn = document.getElementById('copyTextBtn');
    const copyHtmlBtn = document.getElementById('copyHtmlBtn');

    let uploadedImages = []; // L∆∞u link ·∫£nh Imgur
    let selectedFiles = [];

    qualityRange.oninput = () => {
      qualityValue.textContent = qualityRange.value;
    };

    dropzone.addEventListener('dragover', e => {
      e.preventDefault();
      dropzone.classList.add('dragging');
    });
    dropzone.addEventListener('dragleave', e => {
      e.preventDefault();
      dropzone.classList.remove('dragging');
    });
    dropzone.addEventListener('drop', e => {
      e.preventDefault();
      dropzone.classList.remove('dragging');
      if(e.dataTransfer.files.length > 0){
        handleFiles(e.dataTransfer.files);
      }
    });

    fileInput.addEventListener('change', e => {
      if(e.target.files.length > 0){
        handleFiles(e.target.files);
      }
    });

    function showStatus(type, msg){
      statusEl.className = 'status';
      if(type==='success') statusEl.classList.add('bg-success');
      else if(type==='error') statusEl.classList.add('bg-danger');
      else statusEl.classList.add('bg-info');
      statusEl.textContent = msg;
    }

    async function compressToWebP(file, quality = 0.6, maxDim = 1920) {
      return new Promise((resolve, reject) => {
        if(!file.type.startsWith('image/')) return reject(new Error('File kh√¥ng ph·∫£i ·∫£nh'));
        const reader = new FileReader();
        const img = new Image();
        reader.onload = e => {
          img.onload = () => {
            let w = img.width;
            let h = img.height;
            if(w > h && w > maxDim){
              h = h * maxDim / w; w = maxDim;
            } else if(h > w && h > maxDim){
              w = w * maxDim / h; h = maxDim;
            }
            const canvas = document.createElement('canvas');
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img,0,0,w,h);
            canvas.toBlob(blob => {
              if(!blob) return reject(new Error('Kh√¥ng th·ªÉ n√©n WebP'));
              const webpFile = new File([blob], file.name.replace(/\.\w+$/,'.webp'), {type:'image/webp'});
              resolve({webpFile, newSize: blob.size});
            }, 'image/webp', quality);
          };
          img.onerror = () => reject(new Error('L·ªói t·∫£i ·∫£nh'));
          img.src = e.target.result;
        };
        reader.onerror = () => reject(new Error('L·ªói ƒë·ªçc file'));
        reader.readAsDataURL(file);
      });
    }

    async function uploadToImgur(file){
      const clientId = 'b12db8b56ab8de6861b50497a0440516844fe9b2'; // THAY TH√ÄNH CLIENT ID C·ª¶A B·∫†N
      const formData = new FormData();
      formData.append('image', file);
      showStatus('info', `ƒêang upload ·∫£nh "${file.name}" l√™n Imgur...`);
      const res = await fetch('https://api.imgur.com/3/image', {
        method: 'POST',
        headers: { Authorization: `Client-ID ${clientId}` },
        body: formData
      });
      const data = await res.json();
      if(data.success) {
        showStatus('success', `Upload ·∫£nh "${file.name}" th√†nh c√¥ng`);
        return data.data.link;
      } else {
        showStatus('error', `Upload ·∫£nh th·∫•t b·∫°i: ${data.data.error || 'L·ªói kh√¥ng r√µ'}`);
        throw new Error('Upload th·∫•t b·∫°i');
      }
    }

    async function handleFiles(files){
      uploadedImages = [];
      selectedFiles = Array.from(files);
      showStatus('info', `ƒêang x·ª≠ l√Ω ${selectedFiles.length} ·∫£nh...`);
      resultArea.style.display = 'none';
      htmlArea.style.display = 'none';
      btnGroup.style.display = 'none';

      for(const file of selectedFiles){
        try {
          const q = parseFloat(qualityRange.value);
          const {webpFile} = await compressToWebP(file, q);
          const link = await uploadToImgur(webpFile);
          uploadedImages.push({name: file.name, link});
        } catch(err) {
          showStatus('error', `L·ªói v·ªõi ·∫£nh ${file.name}: ${err.message}`);
          return;
        }
      }
      showStatus('success', `ƒê√£ upload th√†nh c√¥ng ${uploadedImages.length} ·∫£nh!`);
    }

    function extractTopicFromFilename(filename){
      let name = filename.replace(/\.[^/.]+$/, "").replace(/[_\-]+/g, ' ');
      return name;
    }

    function htmlEscape(str) {
      return str.replace(/[&<>"']/g, function(m) {
        switch(m) {
          case '&': return '&amp;';
          case '<': return '&lt;';
          case '>': return '&gt;';
          case '"': return '&quot;';
          case "'": return '&#39;';
          default: return m;
        }
      });
    }

    // Chuy·ªÉn ƒëo·∫°n text AI (string) th√†nh HTML (c√≥ <p> t·ª´ng ƒëo·∫°n) + ch√®n ·∫£nh
    function buildHtmlContent(text, images){
      // T√°ch ƒëo·∫°n theo xu·ªëng d√≤ng ƒë√¥i ho·∫∑c ƒë∆°n
      const paragraphs = text.split(/\n{1,2}/).filter(p => p.trim().length > 0);

      // Gi·∫£ s·ª≠ ƒëo·∫°n ƒë·∫ßu ti√™n c√≥ th·ªÉ l√† ti√™u ƒë·ªÅ (n·∫øu ng·∫Øn < 100 k√Ω t·ª±)
      let html = '';
      if(paragraphs.length > 0 && paragraphs[0].length < 100){
        html += `<h2>${htmlEscape(paragraphs[0])}</h2>\n`;
        paragraphs.shift();
      }
      // T·∫°o c√°c ƒëo·∫°n <p>
      paragraphs.forEach(p => {
        html += `<p>${htmlEscape(p)}</p>\n`;
      });
      // Ch√®n ·∫£nh cu·ªëi b√†i
      if(images.length > 0){
        html += `<div>\n`;
        images.forEach(img => {
          html += `<img src="${img.link}" alt="·∫¢nh ${htmlEscape(img.name)}" style="max-width:100%; margin-bottom:15px; border-radius:10px;" />\n`;
        });
        html += `</div>`;
      }
      return html;
    }

    async function generateSEOContent(){
      if(uploadedImages.length === 0){
        showStatus('error', 'B·∫°n ch∆∞a upload ·∫£nh n√†o!');
        return;
      }
      showStatus('info', 'ƒêang t·∫°o b√†i vi·∫øt AI, vui l√≤ng ƒë·ª£i...');
      generateBtn.disabled = true;
      resultArea.style.display = 'none';
      htmlArea.style.display = 'none';
      btnGroup.style.display = 'none';

      const firstImage = uploadedImages[0];
      const topic = extractTopicFromFilename(firstImage.name);

      let imagesListText = uploadedImages.map(img => `- ·∫¢nh: ${img.link}`).join('\n');

      const prompt = `
B·∫°n l√† chuy√™n gia vi·∫øt b√†i chu·∫©n SEO v·ªÅ ch·ªß ƒë·ªÅ "${topic}".
Vi·∫øt b√†i kho·∫£ng 500 t·ª´, c√≥ ch√®n h√¨nh ·∫£nh minh h·ªça sau ƒë√¢y (b·∫°n c√≥ th·ªÉ nh·∫Øc ƒë·∫øn c√°c ·∫£nh ho·∫∑c link ·∫£nh trong b√†i):
${imagesListText}

N·ªôi dung b√†i vi·∫øt h·∫•p d·∫´n, thu h√∫t, chu·∫©n SEO, ph√π h·ª£p ƒëƒÉng tr√™n blog ho·∫∑c m·∫°ng x√£ h·ªôi.
      `;

      try {
        const openaiKey = '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'; // THAY KEY OPENAI C·ª¶A B·∫†N V√ÄO ƒê√ÇY
        const response = await fetch('https://api.openai.com/v1/chat/completions',{
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${openaiKey}`
          },
          body: JSON.stringify({
            model: "gpt-4o-mini",
            messages: [{role: "user", content: prompt}],
            temperature: 0.7,
            max_tokens: 700
          })
        });
        if(!response.ok){
          const err = await response.json();
          throw new Error(err.error.message || 'L·ªói API OpenAI');
        }
        const data = await response.json();
        const content = data.choices[0].message.content.trim();

        resultArea.textContent = content;
        resultArea.style.display = 'block';

        // T·∫°o HTML
        const htmlContent = buildHtmlContent(content, uploadedImages);
        htmlArea.textContent = htmlContent;
        htmlArea.style.display = 'block';

        btnGroup.style.display = 'block';
        showStatus('success', 'T·∫°o b√†i vi·∫øt th√†nh c√¥ng! B·∫°n c√≥ th·ªÉ copy n·ªôi dung ho·∫∑c m√£ HTML.');

      } catch (error) {
        showStatus('error', `L·ªói t·∫°o b√†i vi·∫øt: ${error.message}`);
      } finally {
        generateBtn.disabled = false;
      }
    }

    copyTextBtn.onclick = () => {
      if(resultArea.textContent){
        navigator.clipboard.writeText(resultArea.textContent)
        .then(() => alert('ƒê√£ copy n·ªôi dung b√†i vi·∫øt thu·∫ßn!'))
        .catch(() => alert('Copy th·∫•t b·∫°i!'));
      }
    };

    copyHtmlBtn.onclick = () => {
      if(htmlArea.textContent){
        navigator.clipboard.writeText(htmlArea.textContent)
        .then(() => alert('ƒê√£ copy m√£ HTML ƒë·ªÉ ƒëƒÉng Blogger ho·∫∑c website!'))
        .catch(() => alert('Copy th·∫•t b·∫°i!'));
      }
    };

    generateBtn.addEventListener('click', generateSEOContent);
  </script>
</body>
</html>
